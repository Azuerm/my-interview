1. 组件通信：
  - 父子组件：props、emit、$parent、ref、$attrs;
  - 兄弟组件:$parent、$root、eventbus、vuex；
  - 跨层级关系：eventbus、vuex、provide+inject；
***
2. v-if和v-for的优先级：
  - (1)实践中不应该把v-if和v-for放在一起；在文档中也指明了
  - (2)在vue2中v-for优先级高于v-if；在vue3中v-if优先级高于v-for
  - (3)只有两种情况会把v-for和v-if放一起；为了过滤一些不需要渲染的列表，为了避免渲染本该隐藏的列表
***
3. vue生命周期：
  - 概念：vue组件从创建到销毁的过程，8个生命周期钩子
  - 生命周期各阶段：创建setup、挂载、更新、销毁 + 错误处理阶段
***
4. v-model的双向绑定使用和原理：
  - (1)双向绑定是：指令v-model，响应式数据绑定到视图
  - (2)v-model是语法糖，默认情况下相当于：value属性 和 @input事件
  - (3)使用：表单项、组件
  - (4)表单项：text、textare绑定:value属性和input事件；checkbox、radio绑定:checked属性和change事件；select绑定:value属性和change事件
  - (5)组件中使用modelValue属性 和 @update：modelValue事件
***
5. vue中如何扩展一个组件：
  (1)逻辑扩展：mixins、extend、composition api；内容扩展：slots
  (2)mixins复用功能：容易出现同名属性和方法
  (3)插槽slots内容分发
***
6. 子组件可以直接改变父组件的数据嘛？
  (1)组件化开发是单项数据流，子组件不能直接改变父组件的数据
  (2)父组件通过props传递数据给子组件，单向下行绑定；父更新向下流动到子组件，反过来不行；子组件通过$emit触发父组件的自定义事件
***
7. vue项目权限管理如何做？控制到按钮级别的权限怎么做？
  (1)权限管理一般是：页面权限和按钮权限
  (2)具体方案分前端和后端：后端提供权限数据，前端利用vuex/pinia存储信息，进行本地缓存；根据权限数据渲染页面和按钮
  (3)利用路由守卫控制页面跳转
  (4)对于复杂场景，可以结合v-permission和Permission 组件
***
8. 对vue响应式的理解
  (1)响应式：数据变化，视图自动更新
  (2)为什么vue需要响应式？避免频繁操作dom，通过数据驱动，数据变化了就立即更新视图
  (3)好处：通过数据响应式，不需要频繁的操作dom，提高开发效率
  (4)vue2响应式原理：object.defineproperty，检测类型有限，数组需要特殊处理、Map、Set不支持；vue3响应式原理：proxy，支持更多类型
***
9. 对虚拟dom的理解
  (1)虚拟dom是一个虚拟的dom对象，本身是一个js对象，通过不同属性描述视图结构
  (2)好处：将真实元素节点抽象成虚拟dom，有效减少直接操作dom，提高性能；方便实现跨平台，虚拟dom可以自定义渲染器，针对不同平台进行渲染
  (3)如何生成？为组件编写template模版，通过compile编译成渲染函数，在挂载过程中调用render函数生成虚拟dom，通过patch转换为真实dom；通过diff算法比较新旧虚拟dom，更新真实dom
10. diff算法
  (1)diff算法：也称patching算法，比较新旧虚拟dom，更新真实dom
  (2)必要性：diff算法可以精确找到发生变化的地方并更新，哪里变化更新哪里
  (3)何时执行：组件中响应式数据变化了，执行更新函数
  (4)执行方式：更新函数再次执行render获得新的虚拟dom，在执行patch函数，并传入新旧虚拟dom，进行比对变化的地方，最后更新真实dom
  (5)patch过程是一个递归过程，遵循深度优先、同层比较的策略
  (6)vue3中引入的更新策略：编译器优化patchFlags、block等
11. vue2和vue3的区别
  (1)vue2是选项是api，vue3是组合式api或setup语法糖形式，可以向下兼容
  (2)细节：
    没有this；
    生命周期没有create，setup等同于create，卸载改成unmounted；
    vue3中v-if优先于v-for；
    根实例创建从 new App 变成 createApp方法
    全局注册，从静态方法调用 转变 为app实例调用 
    新增了teleport组件
    根div里面可以包含多个template
  (3)vue2和vue3 双向绑定 方法不同
    vue2：object.defineproperty()后添加的属性无法响应式
    vue3: new proxy()后添加的属性可以响应式，不需要循环
  (4)响应式原理不同
    vue2：object.defineproperty() 无法检测到对象属性的添加或删除，需要Vue.set()和Vue.delete();数组无法通过索引修改
    vue3：new proxy() 可以检测到对象属性的添加或删除，数组可以通过索引修改
  (5)支持按需引入，更好支持tree-shaking
***
12. vue3新特性
  (1)api层面Vue3新特性主要包括：composition api、setup语法糖、teleport传送门、fragments片段、emits选项、自定义渲染器、SFC CSS变量(自定义css变量)、suspense组件
  (2)更快：虚拟dom的重写；编译器优化：静态提升、patchFlags、block等；
  基于proxy的响应式系统；
    更小：更好的摇树优化；
    更易维护：typescript+模块化
    更容易扩展：独立的响应化模块、自定义渲染器
***
13. 怎么定义动态路由？怎么获取传过来的动态参数？
  (1)动态路由：url中包含可变部分，可变部分可以作为参数传递给对应的页面组件
  (2)何时使用：例如有一个user组件，本应该对所有用户渲染，但用户id不同，在vue router中，可以在路径中使用动态参数来实现 {path:'/user/:id',components：User},其中 :id 是动态参数
  (3)怎么定义：路径参数用 : 冒号表示
  (4)获取参数：当一个路由被匹配时，它的params的值将在每个组件中作为以this.$route.params形式暴露出来;或者vue3中使用useRoute()获取
  (5)参数还可以有多个
***
14. 从零写一个vue路由
  (1)SPA应用的路由掘金：点击页面跳转，内容改变，但页面不刷新，路由以插件的形式存在
  (2)实现： 1.在router/index.js中定义路由规则，判断哪些路由懒加载； 2.创建路由组件 router-view、router-link； 3.配置路由导航守卫；  4.通过$route.params或者usreRoute()获取路由参数
***
15. key的作用
  (1)key的作用：更高效的更新虚拟dom；优化更新diff算法，提高patch性能
  (2)必要性：vue在patch过程中，判断两个节点是不是 相同节点通过key；相同节点可以复用，不定义key会频繁更新元素，导致patch过程变慢
  (3)使用：v-for循环中使用key，作为唯一标识每个节点，应该避免使用数组索引作为key
  (4)从源代码中可以知道，vue判断两个节点是否相同，主要判断他们的key和元素类型等，如果不设置key，他们的key就是undefined，则可能永远认为是两个相同节点，导致频繁更新，造成大量dom更新操作
*** 
16. vue3项目如何打包优化，减少包体积，以及首屏渲染速度？
 - (1) 代码分隔和懒加载
 - (2) 按需引入
 - (3) 使用tree-shaking
 - (4) 压缩资源
 - (5) 排除大型依赖
 * 首屏渲染速度优化：
 - (1) 预加载关键资源：rel 和 as
 - (2) 服务端渲染SSR、nuxt.js
 - (3) 骨架屏
 - (4) cdn加速静态资源
 - (5) 使用gzip压缩
***
16. nextTick的使用和原理
  (1)nextTick:等待dom更新完成之后执行回调函数
  (2)为什么需要？vue是异步更新策略，如果数据变化了，vue不会立即更新，而是开启一个队列，在同一事件循环所有数据变更会异步的批量更新，在dom更新之后执行回调函数，需要使用nextTick
  (3)何时使用？created中想要获取dom；响应式数据变化后，想立即获取更新后的dom
  (4)如何使用？nextTick(callback) 或者用 await nextTick() 异步之后再获取dom
***
17. watch和computed的区别以及选择？
  - (1)computed:计算属性，依赖其他属性值，可以缓存结果，只有依赖的属性值变化了，才会重新计算，更新缓存值和视图
  - (2)watch:监听属性变化，当监听属性变化了，执行回调函数，不缓存结果
  - (3)computed的特点：具有只读的响应式的返回值，但也可写读；watch特点：检测变化，执行回调函数
  - (4)选择：
    * computed：用在模版中比较多，同步的
    * eatch： 状态变化之后做一些额外的dom操作或异步操作，异步的
***
18. watch和watchEffect有什么区别
  - (1)watch：指定监听的数据，可以获得变化前后的值以及类型，不会立即执行除非设置immediate为true
  - (2)watchEffect：不需要指定监听的数据，只能获得变化后的值，会立即执行
***
19. 父组件和子组件的创建以及挂载顺序
  - (1)创建过程：父组件 -> 子组件，从外到内
  - (2)挂载过程：子组件 -> 父组件，从内到外
  - (3)更新过程：父组件 -> 子组件，从外到内
  - (4)卸载过程：子组件 -> 父组件，从内到外
  - (5)原理：vue创建过程是递归的，先创建父组件，再创建子组件，挂载过程是递归的，先挂载子组件，再挂载父组件
***
20. 如何缓存当前的组件？缓存后怎么更新？
  - (1)组件缓存：keep-alive，keep-alive包裹动态组件，会缓存不活动的组件实例，而不是销毁；组件的状态保存在内存，防止重复渲染
  - (2)使用router-view包裹keep-alive，结合属性include和exclude明确需要缓存的组件
  - (3)缓存后更新和获取：利用actived 和 beforeRouteEnter 钩子函数； actived组件被激活时都会执行，beforeRouteEnter在有路由的项目，每次进入路由都会执行
***
21. 从0到1自己构建一个vue项目，有哪些步骤、哪些重要插件、目录结构？
  - (1)从0创建一个项目：项目构建、引入必要插件、代码规范、提交规范、常用库和组件
  - (2)目前vue3项目我会用vite或者vue create创建项目
  - (3)引入必要的插件：路由插件vue-router、状态管理vuex或pinia、ui库element-plus或ant-design-vue、http工具我会选axios
  - (4)代码规范：eslint、prettier
  - (5)提交规范：husky、commitlint
  - (6)目录结构：src、components、views、assets、utils、store、router、api、config
***
22. 实际工作中，你总结的vue最佳实践有哪些?
  - (1)编码风格：
      * 命名组件是使用 多词 风格避免和html元素冲突
      * 使用 细节化 定义属性而不是只有一个属性名
      * 属性声明时使用驼峰命名法，模版或jsx中使用短横线命名法
      * 使用v-for必须加key，不能和v-if同时使用
  - (2)性能方面：
      * 路由懒加载减少应用体积
      * 利用SSR减少首屏加载时间
      * 利用v-once渲染不需要更新的内容
      * 一些长列表可以使用虚拟滚动技术避免内存过度占用
      * 对于深层嵌套对象的大数组可以使用shallowRef或shallowReactive降低开销
      * 避免不必要的组件抽象
  - (3)安全方面：
      * 不使用不可信模版
      * 小心使用v-html、：url、：style，避免html、url、样式等的注入
***
23. 对vuex的理解
  - (1)vuex:状态管理模式和库，采用集中式存储，管理所有组件的状态
  - (2)必要性：实现数据共享，集中管理数据，不会破坏数据的单向性，方便开发和维护
  - (3)何时使用：开发大型单页应用时，vuex是基本标配
  - (4)缺点：模版代码多state、mutation、action；ts支持弱，模板化复杂
  - (5)mutation是同步的，action是异步的，mutation是唯一修改state的地方
***
24. 从template到render处理过程分析
  - (1)vue中有一个独特的编译器模块compiler，将用户编写的template模版编译成JS中可执行的render函数
  - (2)必要性：便于高效编写视图模块
  - (3)何时执行：两个构建版本
      * 完整版，在运行时编译，在浏览器中执行
      * 运行时版本，在构建时编译
***
25. vue实例挂载过程中发生了什么？
  - (1)挂载过程指的是app.mount()过程，这是一个初始化过程，整体做两件事:初始化和建立更新机制；虚拟dom转换为真实dom
  - (2)初始化会创建组件实例、初始化组件状态、创建各种响应式数据
  - (3)建立更新机制：执行内部响应式数据和组件更新函数之间的依赖关系，当数据变化时更新组件
***
26. vue3设计目标是什么？做了哪些优化？
  - (1)设计目标：替代vue2，更小更快，更易维护，更好扩展
  - (2)易用性：api的简化；比如vue3中的v-model替代了vue2中的v-model和.sync修饰符
  - (3)开发方面，新组建teleport传送门、fragments片段、suspense异步组件等简化代码编写
  - (4)扩展性：独立reactivity模块，custom renderer自定义渲染器
  - (5)可维护性：组合式api更易编写复用性逻辑
  - (6)性能方面：编译器优化、基于proxy的响应式系统
27. vue3中进行的编译优化有哪些？
  * 静态内容提升、分支预处理、事件侦听器缓存、更高效的虚拟dom、动态组件的优化、指令的优化
***
28. vue有哪些性能优化方法？
  - (1)路由懒加载
  - (2)组件缓存，避免重复创建组件实例
  - (3)使用v-show复用dom
  - (4)v-for避免和v-if同时使用
  - (5)v-once和v-memo，不在变化的数据使用v-once；只对部分数据变化使用v-memo
  - (6)长列表性能优化，可以常用虚拟滚动，只渲染少部分的区域
  - (7)事件销毁，自己定义的事件，在组件销毁时，要手动销毁
  - (8)图片懒加载、骨架屏
  - (9)插件按需引入
***
29. vue为什么只有一个根节点？
  - (1)vue3中可以有多个根节点，但vue2中只能有一个根节点
  - (2)vue2中只有一个根节点，是因为vue2是单根树形结构；而vue3是单文件组件，一个文件就是一个组件，所以可以多个根节点
  - (3)vue3中多个根节点，是因为vue3中使用了Fragment片段，Fragment可以包含多个根节点
30. 什么情况适用vuex模块？
  - (1)项目规模变大，单独一个store对象庞大，vuex通过模块拆分进行维护
  - (2)使用：先按之前规则编写子模块代码，然后主文件中通过modules组织起来
  - (3)使用时：访问子模块要加注册时的模块名；如果需要完成拆分开启命名空间namespace，访问要加命名空间前缀
  - (4)缺点：使用繁琐，支持类型差，用pinia替代
31. 从vuex转换为使用pinia，介绍一下pinia，做了哪些改善呢？
  - (1)pinia是一个状态管理库，替代vuex
  - (2)改善：模块化设计更直观，无需严格模式、更好支持TS、action不再强制同步返回、getter不需要依赖state或其他getters
33. 怎么实现路由懒加载？
  - (1)必要性：路由懒加载吧路由分割成不同的代码块，优化页面加载速度
  - (2)何时用：只有路由被访问的时候才加载对应的组件
  - (3)怎么用：给components选项配置一个返回promise组件的函数
  - (4)路由中不能使用异步组件，组件中可以使用异步组件
34. ref和reactive的区别？
  - (1)ref接收内部的值返回一个响应式对象，reactive返回响应式代理对象
  - (2)ref通常用来处理基本数据类型，reactive用来处理对象或者数组
  - (3)ref返回的响应式在JS中通过.value访问，视图上不需要.value访问；reactive返回的响应式在JS和视图都不需要.value访问，可以通过toRefs转换为ref对象
  - (4)ref的响应式原理是object.defineProperty，reactive的响应式原理是Proxy
35. SPA和SSR的区别？
  - (1)SPA:单页应用，称为客户端渲染；SSR：服务端渲染，称为多页面应用
  - (2)SPA只有首次请求html文件，后续只需要请求json数据；因为用户体验好，节约流量，服务器压力小；但首屏加载时间长，SEO不友好。为了解决spa的缺点，利用SSR方案，HTML文件内容在服务器一次性生成，首屏加载快，SEO友好
  - (3)在选择上，如果存在首屏加载优化需求，SEO需求时，可以考虑SSR
  - (4)并不是只有一种替代方案，比如一些不常改变的页面，可以考虑使用预渲染方案或者SSG静态网站生成方法
36. vue-loader是什么？有什么作用？
  - (1)vue-loader是webpack的加载器，用于把.vue文件转换成js模块
  - (2)作用：把.vue文件中的template、script、style等转换成js模块，支持预处理css、预编译scss、less等
  - (3)webpack打包的时候，会以loader的方式调用vue-loader
37. 你有写过自定义指令吗？自定义指令的应用场景有哪些？
  - (1)vue有一组默认指令，比如v-model或v-for等，同时vue也允许用户注册自定义指令
  - (2)自定义指令主要完成一些可复用低层级dom操作
  - (3)使用自定义指令分为：定义、注册和使用三步
      * 定义自定义指令有两种方式：对象和函数；对象方式类似于组件定义，有各种生命周期；函数方式只能在mounted和updated时执行
      * 注册自定义指令类似组件，可以使用app.drective()全局注册，使用{directives：{xxx}}局部注册
      * 使用是在注册名称前加上-v，比如v-focus
  - (4)我在项目中常用到一些自定义指令，比如：复制粘贴v-copy、长按v-longpress、防抖v-debounce、图片懒加载v-lazy、按钮权限v-permission、页面水印v-watermark、拖拽指令
38. $attrs和$listeners的使用场景？
  - (1)有一些属性和事件没有在props中声明-非属性特性，结合v-bind指令可以透传给子组件
  - (2)使用场景：属性透传，比如A组件包含B组件，B组件包含C组件，A组件想给C组件传递props，但是A组件没有声明props，这时候就可以使用v-bind="$attrs"透传
  - (3)常见用法结合v-bind，$attrs本身不是响应式，除非访问的属性本身是响应式
  - (4)vue2中使用listeners获取事件，vue3中移除，合并到$attrs中
39. v-once的使用场景有哪些？
  - (1)v-once是vue的内置指令，作用是：只渲染指定组件或元素一次，并跳过未来的更新
  - (2)何时使用：如果有一些元素或组件在初始化渲染之后不再需要改变
  - (3)如何使用：在需要作用的组件或元素加上v-once即可
  - (4)扩展v-memo：vue3.2新增了v-memo指令，可以有条件缓存部分模版并控制他们的更新，可以说控制力更强了
  - (5)编译器发现元素上有v-once，会将首次计算结果存入缓存对象，组件再次渲染是就从缓存获取，从而避免再次计算
40. vue中什么是递归组件？使用场景有哪些？
  - (1)如果某个组件通过组件名引用它自己
  - (2)使用场景：实际开发中类似Tree、Menu这类组件，他们的节点往往包含子节点，子节点结构和父节点往往相同，这些组件数据往往是树形结构，这种场景下递归组件就派上用场了
41. 异步组件时什么？使用场景有哪些？
  - (1)作用：在大型应用中，需要分隔应用为更小的块，并且在需要组件时再加载他们
  - (2)何时使用：在路由切换时懒加载组件，在页面组件中使用异步组件
  - (3)使用细节：
    * 使用异步组件最简单的方式是使用 defineAsyncComponent()函数 + import()函数；
    * 也可以指定loadingComponent和errorComponent选项提供更好的用户体验；
    * vue3中新增 suspense组件
  - (4)异步组件和路由懒加载不是一个东西：
    * 异步组件是处理vue框架的，不能被定义到懒加载路由上，
    * 路由懒加载处理是由vue-router框架的；懒加载的路由组件可以使用异步组件
42. 如何处理vue项目中的错误？
  - (1)区分错误类型：接口异常 和 代码逻辑异常
  - (2)根据错误不同类型做响应收集：
    * 接口异常，通常封装axios，在拦截器中统一处理
    * 代码逻辑异常，通常使用app.config.errorHandler全局错误处理函数，或者try catch
43. 如何从0实现vuex？
  - (1)vuex是一个状态管理库，确保状态以预期的方式变更
  - (2)实现vuex：
    * 利用store存储全局状态：定义store类、构造函数接收选项options、设置属性state对外暴露、提供commit和dispatch修改属性state、同时将store定义为一个vue插件
    * 提供修改状态所需的api：commit方法可以获取用户传入mutation并执行它，dispatch方法可以获取用户传入action并执行它
44. vuex中actions和mutations的区别是什么？
  - (1)官方文档中提到：更改vuex的store中的状态的唯一方法是提交mutation，每一mutation都有一个字符串类型和一个回调函数。action类似mutation，不同在于：action可以包含任意异步操作，但不能修改状态，需要提交mutation才能修改状态
  - (2)何时使用：开发中包含异步操作或者复杂业务是使用actions；需要直接修改状态时使用mutations；dispatch是和action配合使用的，commit是和mutation配合使用的
45. 使用vue渲染大量数据时应该怎么优化？
  - (1)在大型企业级项目中经常需要渲染大量数据，此时很容易出现卡顿，严重影响用户体验
  - (2)处理是要根据情况的不同处理： 
    * 避免大数据量：可以采用分页的方式获取
    * 避免渲染大量数据：采用虚拟滚动方案，只渲染视口范围的数据
    * 避免更新：使用v-once方式只渲染一次
    * 优化更新：通过v-memo缓存数据，有条件更新
46. 怎么监听vuex中数据的变化？
  - (1)两种方法：watch方法和store.subscribe()方法
  - (2)watch方法监听某个值的变化，变化了执行回调函数；subscribe方法监听所有值的变化，需要通过type区分变化的类型，变化了执行回调函数
47. router-link和router-view是如何起作用的？
  - (1)router-link导航到指定url；router-view渲染组件到视图中
  - (2)router-link的实现：本质是一个a标签，但阻止默认跳转行为，使用vue router的push或replace方法切换视图
  - (2)router-view的实现：本质是一个组件，通过vue router的current属性获取当前路由信息，然后渲染对应的组件
48. vue3性能提升体现在哪些方面？
  - (1)从代码、编码、打包三方面介绍vue3性能方面的提升
  - (2)代码层面性能优化只要体现在全新响应式api，基于proxy实现，初始化时间和内存占用均大幅改进
  - (3)编码层面做了更多编码优化处理，比如：静态提升，动态内容标记、事件缓存、区域等，可以有效跳过大量diff过程
  - (4)打包时更好支持tree-shaking，因此整体体积更小，加载更快
49. vue3中为什么要用proxy代替defineProperty？
  - (1)defineProperty只能监听对象属性的变化，不能监听对象新增属性和删除属性的变化,也不能监听数组的变化；defineproperty在初始化时需要遍历对象的所有属性，性能消耗较大
  - (2)proxy可以监听对象的所有变化，包括新增属性和删除属性的变化，也可以监听数组的变化；proxy在初始化时不需要遍历对象的所有属性，性能消耗较小，还可以对map、set等数据结构进行监听
50. history模式和hash模式有何区别？
  - (1)hash模式：在地址栏显示带#，这种方式使用和部署都比较简单
  - (2)history模式：在地址栏显示不带#，这种方式需要web服务器做配置，否则会出现刷新404的问题
  - (3)hash模式原理：通过监听hashchange事件；history模式原理：通过监听popstate事件和pushstate事件
51. 什么场景会用到嵌套路由？
  - (1)在一个页面中包含多个子页面
  - (2)表现形式是在两个路由直接切换时，他们有公共的视图内容，此时通常提取一个父组件，内部放上router-view，形成嵌套路由。定义嵌套路由时使用children属性组织嵌套关系
52. 页面刷新后vuex的state数据丢失怎么解决？
  - (1)vuex只是在内存中存储数据，刷新后会丢失，所以要持久化存储
  - (2)简单数据可以使用localstorage；复杂数据可以使用vuex-persistedstate插件或者cookie
53. 你觉得vuex有什么缺点？
  - (1)vuex利用响应式，但使用过程中模块化非常复杂，用的时候容易出错，要经常查看文档
  - (2)比如：访问state是要带上模块名，如果模块名很长，要配合mapstate使用；还有要不要加namespace命名空间；对ts支持不友好，在使用模块时没有代码提示
54. composition api和options api的区别？
  - (1)composition api按逻辑组织代码，options api按功能组织代码
  - (2)options api中依赖mixins容易出现命名冲突，composition api中依赖的变量名不会冲突


  

实现步骤：

1.请求相关业务设计
  1. 用户信息判断
  2. 接口提交的方式（get/post）
  3. 提交的数据格式（json/from）
  4. 请求头设置 （token、是否缓存）


2.响应拦截相设计
  1. 判决接口是否异常处理
  2. 判断用户身份是否过期处理
  3. 判断返回数据结果处理


问: vue中，不使用第三方组件库，如何封装？
1. 基础结构封装,例如HTML/-
2. 公共样式抽离, 例如：主题样式，默认样式
3. 模块化分类管理
4. 对公共组件化进阶分离，导出使用
5. 使用AI生成组件代码

父亲创建前 -> 子组创建前 -> 子创建后 -

